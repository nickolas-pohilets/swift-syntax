//// Automatically generated by generate-swiftsyntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - DeclSyntax

/// Protocol to which all ``DeclSyntax`` nodes conform. Extension point to add
/// common methods to all ``DeclSyntax`` nodes.
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeclSyntaxProtocol: SyntaxProtocol {}

public extension Syntax {
  /// Check whether the non-type erased version of this syntax node conforms to
  /// DeclSyntaxProtocol.
  /// Note that this will incur an existential conversion.
  func isProtocol(_: DeclSyntaxProtocol.Protocol) -> Bool {
    return self.asProtocol(DeclSyntaxProtocol.self) != nil
  }
  
  /// Return the non-type erased version of this syntax node if it conforms to
  /// DeclSyntaxProtocol. Otherwise return nil.
  /// Note that this will incur an existential conversion.
  func asProtocol(_: DeclSyntaxProtocol.Protocol) -> DeclSyntaxProtocol? {
    return self.asProtocol(SyntaxProtocol.self) as? DeclSyntaxProtocol
  }
}

public struct DeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  /// Create a ``DeclSyntax`` node from a specialized syntax node.
  public init(_ syntax: some DeclSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``DeclSyntax`` node from a specialized optional syntax node.
  public init?(_ syntax: (some DeclSyntaxProtocol)?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(syntax)
  }
  
  public init(fromProtocol syntax: DeclSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``DeclSyntax`` node from a specialized optional syntax node.
  public init?(fromProtocol syntax: DeclSyntaxProtocol?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(fromProtocol: syntax)
  }
  
  public init?(_ node: some SyntaxProtocol) {
    switch node.raw.kind {
    case .accessorDecl, .actorDecl, .associatedtypeDecl, .classDecl, .deinitializerDecl, .editorPlaceholderDecl, .enumCaseDecl, .enumDecl, .extensionDecl, .functionDecl, .ifConfigDecl, .importDecl, .initializerDecl, .macroDecl, .macroExpansionDecl, .missingDecl, .operatorDecl, .poundSourceLocation, .precedenceGroupDecl, .protocolDecl, .structDecl, .subscriptDecl, .typealiasDecl, .variableDecl:
      self._syntaxNode = node._syntaxNode
    default:
      return nil
    }
  }
  
  /// Creates a ``DeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the ``SyntaxData`` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    switch data.raw.kind {
    case .accessorDecl, .actorDecl, .associatedtypeDecl, .classDecl, .deinitializerDecl, .editorPlaceholderDecl, .enumCaseDecl, .enumDecl, .extensionDecl, .functionDecl, .ifConfigDecl, .importDecl, .initializerDecl, .macroDecl, .macroExpansionDecl, .missingDecl, .operatorDecl, .poundSourceLocation, .precedenceGroupDecl, .protocolDecl, .structDecl, .subscriptDecl, .typealiasDecl, .variableDecl:
      break
    default:
      preconditionFailure("Unable to create DeclSyntax from \(data.raw.kind)")
    }
    self._syntaxNode = Syntax(data)
  }
  
  public func `is`<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }
  
  public func `as`<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
  
  public func cast<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> S {
    return self.as(S.self)!
  }
  
  /// Syntax nodes always conform to `DeclSyntaxProtocol`. This API is just
  /// added for consistency.
  /// Note that this will incur an existential conversion.
  @available(*, deprecated, message: "Expression always evaluates to true")
  public func isProtocol(_: DeclSyntaxProtocol.Protocol) -> Bool {
    return true
  }
  
  /// Return the non-type erased version of this syntax node.
  /// Note that this will incur an existential conversion.
  public func asProtocol(_: DeclSyntaxProtocol.Protocol) -> DeclSyntaxProtocol {
    return Syntax(self).asProtocol(DeclSyntaxProtocol.self)!
  }
  
  public static var structure: SyntaxNodeStructure {
    return .choices([
          .node(AccessorDeclSyntax.self),
          .node(ActorDeclSyntax.self),
          .node(AssociatedtypeDeclSyntax.self),
          .node(ClassDeclSyntax.self),
          .node(DeinitializerDeclSyntax.self),
          .node(EditorPlaceholderDeclSyntax.self),
          .node(EnumCaseDeclSyntax.self),
          .node(EnumDeclSyntax.self),
          .node(ExtensionDeclSyntax.self),
          .node(FunctionDeclSyntax.self),
          .node(IfConfigDeclSyntax.self),
          .node(ImportDeclSyntax.self),
          .node(InitializerDeclSyntax.self),
          .node(MacroDeclSyntax.self),
          .node(MacroExpansionDeclSyntax.self),
          .node(MissingDeclSyntax.self),
          .node(OperatorDeclSyntax.self),
          .node(PoundSourceLocationSyntax.self),
          .node(PrecedenceGroupDeclSyntax.self),
          .node(ProtocolDeclSyntax.self),
          .node(StructDeclSyntax.self),
          .node(SubscriptDeclSyntax.self),
          .node(TypealiasDeclSyntax.self),
          .node(VariableDeclSyntax.self)
        ])
  }
}

// MARK: - ExprSyntax

/// Protocol to which all ``ExprSyntax`` nodes conform. Extension point to add
/// common methods to all ``ExprSyntax`` nodes.
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ExprSyntaxProtocol: SyntaxProtocol {}

public extension Syntax {
  /// Check whether the non-type erased version of this syntax node conforms to
  /// ExprSyntaxProtocol.
  /// Note that this will incur an existential conversion.
  func isProtocol(_: ExprSyntaxProtocol.Protocol) -> Bool {
    return self.asProtocol(ExprSyntaxProtocol.self) != nil
  }
  
  /// Return the non-type erased version of this syntax node if it conforms to
  /// ExprSyntaxProtocol. Otherwise return nil.
  /// Note that this will incur an existential conversion.
  func asProtocol(_: ExprSyntaxProtocol.Protocol) -> ExprSyntaxProtocol? {
    return self.asProtocol(SyntaxProtocol.self) as? ExprSyntaxProtocol
  }
}

public struct ExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  /// Create a ``ExprSyntax`` node from a specialized syntax node.
  public init(_ syntax: some ExprSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``ExprSyntax`` node from a specialized optional syntax node.
  public init?(_ syntax: (some ExprSyntaxProtocol)?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(syntax)
  }
  
  public init(fromProtocol syntax: ExprSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``ExprSyntax`` node from a specialized optional syntax node.
  public init?(fromProtocol syntax: ExprSyntaxProtocol?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(fromProtocol: syntax)
  }
  
  public init?(_ node: some SyntaxProtocol) {
    switch node.raw.kind {
    case .arrayExpr, .arrowExpr, .asExpr, .assignmentExpr, .awaitExpr, .binaryOperatorExpr, .booleanLiteralExpr, .borrowExpr, .canImportExpr, .canImportVersionInfo, .closureExpr, .copyExpr, .dictionaryExpr, .discardAssignmentExpr, .editorPlaceholderExpr, .floatLiteralExpr, .forcedValueExpr, .functionCallExpr, .identifierExpr, .ifExpr, .inOutExpr, .infixOperatorExpr, .integerLiteralExpr, .isExpr, .keyPathExpr, .macroExpansionExpr, .memberAccessExpr, .missingExpr, .moveExpr, .nilLiteralExpr, .optionalChainingExpr, .packElementExpr, .packExpansionExpr, .postfixIfConfigExpr, .postfixUnaryExpr, .prefixOperatorExpr, .regexLiteralExpr, .sequenceExpr, .specializeExpr, .stringLiteralExpr, .subscriptExpr, .superRefExpr, .switchExpr, .ternaryExpr, .tryExpr, .tupleExpr, .typeExpr, .unresolvedAsExpr, .unresolvedIsExpr, .unresolvedPatternExpr, .unresolvedTernaryExpr:
      self._syntaxNode = node._syntaxNode
    default:
      return nil
    }
  }
  
  /// Creates a ``ExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the ``SyntaxData`` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    switch data.raw.kind {
    case .arrayExpr, .arrowExpr, .asExpr, .assignmentExpr, .awaitExpr, .binaryOperatorExpr, .booleanLiteralExpr, .borrowExpr, .canImportExpr, .canImportVersionInfo, .closureExpr, .copyExpr, .dictionaryExpr, .discardAssignmentExpr, .editorPlaceholderExpr, .floatLiteralExpr, .forcedValueExpr, .functionCallExpr, .identifierExpr, .ifExpr, .inOutExpr, .infixOperatorExpr, .integerLiteralExpr, .isExpr, .keyPathExpr, .macroExpansionExpr, .memberAccessExpr, .missingExpr, .moveExpr, .nilLiteralExpr, .optionalChainingExpr, .packElementExpr, .packExpansionExpr, .postfixIfConfigExpr, .postfixUnaryExpr, .prefixOperatorExpr, .regexLiteralExpr, .sequenceExpr, .specializeExpr, .stringLiteralExpr, .subscriptExpr, .superRefExpr, .switchExpr, .ternaryExpr, .tryExpr, .tupleExpr, .typeExpr, .unresolvedAsExpr, .unresolvedIsExpr, .unresolvedPatternExpr, .unresolvedTernaryExpr:
      break
    default:
      preconditionFailure("Unable to create ExprSyntax from \(data.raw.kind)")
    }
    self._syntaxNode = Syntax(data)
  }
  
  public func `is`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }
  
  public func `as`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
  
  public func cast<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> S {
    return self.as(S.self)!
  }
  
  /// Syntax nodes always conform to `ExprSyntaxProtocol`. This API is just
  /// added for consistency.
  /// Note that this will incur an existential conversion.
  @available(*, deprecated, message: "Expression always evaluates to true")
  public func isProtocol(_: ExprSyntaxProtocol.Protocol) -> Bool {
    return true
  }
  
  /// Return the non-type erased version of this syntax node.
  /// Note that this will incur an existential conversion.
  public func asProtocol(_: ExprSyntaxProtocol.Protocol) -> ExprSyntaxProtocol {
    return Syntax(self).asProtocol(ExprSyntaxProtocol.self)!
  }
  
  public static var structure: SyntaxNodeStructure {
    return .choices([
          .node(ArrayExprSyntax.self),
          .node(ArrowExprSyntax.self),
          .node(AsExprSyntax.self),
          .node(AssignmentExprSyntax.self),
          .node(AwaitExprSyntax.self),
          .node(BinaryOperatorExprSyntax.self),
          .node(BooleanLiteralExprSyntax.self),
          .node(BorrowExprSyntax.self),
          .node(CanImportExprSyntax.self),
          .node(CanImportVersionInfoSyntax.self),
          .node(ClosureExprSyntax.self),
          .node(CopyExprSyntax.self),
          .node(DictionaryExprSyntax.self),
          .node(DiscardAssignmentExprSyntax.self),
          .node(EditorPlaceholderExprSyntax.self),
          .node(FloatLiteralExprSyntax.self),
          .node(ForcedValueExprSyntax.self),
          .node(FunctionCallExprSyntax.self),
          .node(IdentifierExprSyntax.self),
          .node(IfExprSyntax.self),
          .node(InOutExprSyntax.self),
          .node(InfixOperatorExprSyntax.self),
          .node(IntegerLiteralExprSyntax.self),
          .node(IsExprSyntax.self),
          .node(KeyPathExprSyntax.self),
          .node(MacroExpansionExprSyntax.self),
          .node(MemberAccessExprSyntax.self),
          .node(MissingExprSyntax.self),
          .node(MoveExprSyntax.self),
          .node(NilLiteralExprSyntax.self),
          .node(OptionalChainingExprSyntax.self),
          .node(PackElementExprSyntax.self),
          .node(PackExpansionExprSyntax.self),
          .node(PostfixIfConfigExprSyntax.self),
          .node(PostfixUnaryExprSyntax.self),
          .node(PrefixOperatorExprSyntax.self),
          .node(RegexLiteralExprSyntax.self),
          .node(SequenceExprSyntax.self),
          .node(SpecializeExprSyntax.self),
          .node(StringLiteralExprSyntax.self),
          .node(SubscriptExprSyntax.self),
          .node(SuperRefExprSyntax.self),
          .node(SwitchExprSyntax.self),
          .node(TernaryExprSyntax.self),
          .node(TryExprSyntax.self),
          .node(TupleExprSyntax.self),
          .node(TypeExprSyntax.self),
          .node(UnresolvedAsExprSyntax.self),
          .node(UnresolvedIsExprSyntax.self),
          .node(UnresolvedPatternExprSyntax.self),
          .node(UnresolvedTernaryExprSyntax.self)
        ])
  }
}

// MARK: - PatternSyntax

/// Protocol to which all ``PatternSyntax`` nodes conform. Extension point to add
/// common methods to all ``PatternSyntax`` nodes.
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PatternSyntaxProtocol: SyntaxProtocol {}

public extension Syntax {
  /// Check whether the non-type erased version of this syntax node conforms to
  /// PatternSyntaxProtocol.
  /// Note that this will incur an existential conversion.
  func isProtocol(_: PatternSyntaxProtocol.Protocol) -> Bool {
    return self.asProtocol(PatternSyntaxProtocol.self) != nil
  }
  
  /// Return the non-type erased version of this syntax node if it conforms to
  /// PatternSyntaxProtocol. Otherwise return nil.
  /// Note that this will incur an existential conversion.
  func asProtocol(_: PatternSyntaxProtocol.Protocol) -> PatternSyntaxProtocol? {
    return self.asProtocol(SyntaxProtocol.self) as? PatternSyntaxProtocol
  }
}

public struct PatternSyntax: PatternSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  /// Create a ``PatternSyntax`` node from a specialized syntax node.
  public init(_ syntax: some PatternSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``PatternSyntax`` node from a specialized optional syntax node.
  public init?(_ syntax: (some PatternSyntaxProtocol)?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(syntax)
  }
  
  public init(fromProtocol syntax: PatternSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``PatternSyntax`` node from a specialized optional syntax node.
  public init?(fromProtocol syntax: PatternSyntaxProtocol?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(fromProtocol: syntax)
  }
  
  public init?(_ node: some SyntaxProtocol) {
    switch node.raw.kind {
    case .expressionPattern, .identifierPattern, .isTypePattern, .missingPattern, .tuplePattern, .valueBindingPattern, .wildcardPattern:
      self._syntaxNode = node._syntaxNode
    default:
      return nil
    }
  }
  
  /// Creates a ``PatternSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the ``SyntaxData`` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    switch data.raw.kind {
    case .expressionPattern, .identifierPattern, .isTypePattern, .missingPattern, .tuplePattern, .valueBindingPattern, .wildcardPattern:
      break
    default:
      preconditionFailure("Unable to create PatternSyntax from \(data.raw.kind)")
    }
    self._syntaxNode = Syntax(data)
  }
  
  public func `is`<S: PatternSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }
  
  public func `as`<S: PatternSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
  
  public func cast<S: PatternSyntaxProtocol>(_ syntaxType: S.Type) -> S {
    return self.as(S.self)!
  }
  
  /// Syntax nodes always conform to `PatternSyntaxProtocol`. This API is just
  /// added for consistency.
  /// Note that this will incur an existential conversion.
  @available(*, deprecated, message: "Expression always evaluates to true")
  public func isProtocol(_: PatternSyntaxProtocol.Protocol) -> Bool {
    return true
  }
  
  /// Return the non-type erased version of this syntax node.
  /// Note that this will incur an existential conversion.
  public func asProtocol(_: PatternSyntaxProtocol.Protocol) -> PatternSyntaxProtocol {
    return Syntax(self).asProtocol(PatternSyntaxProtocol.self)!
  }
  
  public static var structure: SyntaxNodeStructure {
    return .choices([
          .node(ExpressionPatternSyntax.self),
          .node(IdentifierPatternSyntax.self),
          .node(IsTypePatternSyntax.self),
          .node(MissingPatternSyntax.self),
          .node(TuplePatternSyntax.self),
          .node(ValueBindingPatternSyntax.self),
          .node(WildcardPatternSyntax.self)
        ])
  }
}

// MARK: - StmtSyntax

/// Protocol to which all ``StmtSyntax`` nodes conform. Extension point to add
/// common methods to all ``StmtSyntax`` nodes.
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol StmtSyntaxProtocol: SyntaxProtocol {}

public extension Syntax {
  /// Check whether the non-type erased version of this syntax node conforms to
  /// StmtSyntaxProtocol.
  /// Note that this will incur an existential conversion.
  func isProtocol(_: StmtSyntaxProtocol.Protocol) -> Bool {
    return self.asProtocol(StmtSyntaxProtocol.self) != nil
  }
  
  /// Return the non-type erased version of this syntax node if it conforms to
  /// StmtSyntaxProtocol. Otherwise return nil.
  /// Note that this will incur an existential conversion.
  func asProtocol(_: StmtSyntaxProtocol.Protocol) -> StmtSyntaxProtocol? {
    return self.asProtocol(SyntaxProtocol.self) as? StmtSyntaxProtocol
  }
}

public struct StmtSyntax: StmtSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  /// Create a ``StmtSyntax`` node from a specialized syntax node.
  public init(_ syntax: some StmtSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``StmtSyntax`` node from a specialized optional syntax node.
  public init?(_ syntax: (some StmtSyntaxProtocol)?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(syntax)
  }
  
  public init(fromProtocol syntax: StmtSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``StmtSyntax`` node from a specialized optional syntax node.
  public init?(fromProtocol syntax: StmtSyntaxProtocol?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(fromProtocol: syntax)
  }
  
  public init?(_ node: some SyntaxProtocol) {
    switch node.raw.kind {
    case .breakStmt, .continueStmt, .deferStmt, .discardStmt, .doStmt, .expressionStmt, .fallthroughStmt, .forInStmt, .guardStmt, .labeledStmt, .missingStmt, .repeatWhileStmt, .returnStmt, .throwStmt, .whileStmt, .yieldStmt:
      self._syntaxNode = node._syntaxNode
    default:
      return nil
    }
  }
  
  /// Creates a ``StmtSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the ``SyntaxData`` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    switch data.raw.kind {
    case .breakStmt, .continueStmt, .deferStmt, .discardStmt, .doStmt, .expressionStmt, .fallthroughStmt, .forInStmt, .guardStmt, .labeledStmt, .missingStmt, .repeatWhileStmt, .returnStmt, .throwStmt, .whileStmt, .yieldStmt:
      break
    default:
      preconditionFailure("Unable to create StmtSyntax from \(data.raw.kind)")
    }
    self._syntaxNode = Syntax(data)
  }
  
  public func `is`<S: StmtSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }
  
  public func `as`<S: StmtSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
  
  public func cast<S: StmtSyntaxProtocol>(_ syntaxType: S.Type) -> S {
    return self.as(S.self)!
  }
  
  /// Syntax nodes always conform to `StmtSyntaxProtocol`. This API is just
  /// added for consistency.
  /// Note that this will incur an existential conversion.
  @available(*, deprecated, message: "Expression always evaluates to true")
  public func isProtocol(_: StmtSyntaxProtocol.Protocol) -> Bool {
    return true
  }
  
  /// Return the non-type erased version of this syntax node.
  /// Note that this will incur an existential conversion.
  public func asProtocol(_: StmtSyntaxProtocol.Protocol) -> StmtSyntaxProtocol {
    return Syntax(self).asProtocol(StmtSyntaxProtocol.self)!
  }
  
  public static var structure: SyntaxNodeStructure {
    return .choices([
          .node(BreakStmtSyntax.self),
          .node(ContinueStmtSyntax.self),
          .node(DeferStmtSyntax.self),
          .node(DiscardStmtSyntax.self),
          .node(DoStmtSyntax.self),
          .node(ExpressionStmtSyntax.self),
          .node(FallthroughStmtSyntax.self),
          .node(ForInStmtSyntax.self),
          .node(GuardStmtSyntax.self),
          .node(LabeledStmtSyntax.self),
          .node(MissingStmtSyntax.self),
          .node(RepeatWhileStmtSyntax.self),
          .node(ReturnStmtSyntax.self),
          .node(ThrowStmtSyntax.self),
          .node(WhileStmtSyntax.self),
          .node(YieldStmtSyntax.self)
        ])
  }
}

// MARK: - TypeSyntax

/// Protocol to which all ``TypeSyntax`` nodes conform. Extension point to add
/// common methods to all ``TypeSyntax`` nodes.
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TypeSyntaxProtocol: SyntaxProtocol {}

public extension Syntax {
  /// Check whether the non-type erased version of this syntax node conforms to
  /// TypeSyntaxProtocol.
  /// Note that this will incur an existential conversion.
  func isProtocol(_: TypeSyntaxProtocol.Protocol) -> Bool {
    return self.asProtocol(TypeSyntaxProtocol.self) != nil
  }
  
  /// Return the non-type erased version of this syntax node if it conforms to
  /// TypeSyntaxProtocol. Otherwise return nil.
  /// Note that this will incur an existential conversion.
  func asProtocol(_: TypeSyntaxProtocol.Protocol) -> TypeSyntaxProtocol? {
    return self.asProtocol(SyntaxProtocol.self) as? TypeSyntaxProtocol
  }
}

public struct TypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  /// Create a ``TypeSyntax`` node from a specialized syntax node.
  public init(_ syntax: some TypeSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``TypeSyntax`` node from a specialized optional syntax node.
  public init?(_ syntax: (some TypeSyntaxProtocol)?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(syntax)
  }
  
  public init(fromProtocol syntax: TypeSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }
  
  /// Create a ``TypeSyntax`` node from a specialized optional syntax node.
  public init?(fromProtocol syntax: TypeSyntaxProtocol?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(fromProtocol: syntax)
  }
  
  public init?(_ node: some SyntaxProtocol) {
    switch node.raw.kind {
    case .arrayType, .attributedType, .classRestrictionType, .compositionType, .constrainedSugarType, .dictionaryType, .functionType, .implicitlyUnwrappedOptionalType, .memberTypeIdentifier, .metatypeType, .missingType, .namedOpaqueReturnType, .optionalType, .packExpansionType, .packReferenceType, .simpleTypeIdentifier, .suppressedType, .tupleType:
      self._syntaxNode = node._syntaxNode
    default:
      return nil
    }
  }
  
  /// Creates a ``TypeSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the ``SyntaxData`` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    switch data.raw.kind {
    case .arrayType, .attributedType, .classRestrictionType, .compositionType, .constrainedSugarType, .dictionaryType, .functionType, .implicitlyUnwrappedOptionalType, .memberTypeIdentifier, .metatypeType, .missingType, .namedOpaqueReturnType, .optionalType, .packExpansionType, .packReferenceType, .simpleTypeIdentifier, .suppressedType, .tupleType:
      break
    default:
      preconditionFailure("Unable to create TypeSyntax from \(data.raw.kind)")
    }
    self._syntaxNode = Syntax(data)
  }
  
  public func `is`<S: TypeSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }
  
  public func `as`<S: TypeSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
  
  public func cast<S: TypeSyntaxProtocol>(_ syntaxType: S.Type) -> S {
    return self.as(S.self)!
  }
  
  /// Syntax nodes always conform to `TypeSyntaxProtocol`. This API is just
  /// added for consistency.
  /// Note that this will incur an existential conversion.
  @available(*, deprecated, message: "Expression always evaluates to true")
  public func isProtocol(_: TypeSyntaxProtocol.Protocol) -> Bool {
    return true
  }
  
  /// Return the non-type erased version of this syntax node.
  /// Note that this will incur an existential conversion.
  public func asProtocol(_: TypeSyntaxProtocol.Protocol) -> TypeSyntaxProtocol {
    return Syntax(self).asProtocol(TypeSyntaxProtocol.self)!
  }
  
  public static var structure: SyntaxNodeStructure {
    return .choices([
          .node(ArrayTypeSyntax.self),
          .node(AttributedTypeSyntax.self),
          .node(ClassRestrictionTypeSyntax.self),
          .node(CompositionTypeSyntax.self),
          .node(ConstrainedSugarTypeSyntax.self),
          .node(DictionaryTypeSyntax.self),
          .node(FunctionTypeSyntax.self),
          .node(ImplicitlyUnwrappedOptionalTypeSyntax.self),
          .node(MemberTypeIdentifierSyntax.self),
          .node(MetatypeTypeSyntax.self),
          .node(MissingTypeSyntax.self),
          .node(NamedOpaqueReturnTypeSyntax.self),
          .node(OptionalTypeSyntax.self),
          .node(PackExpansionTypeSyntax.self),
          .node(PackReferenceTypeSyntax.self),
          .node(SimpleTypeIdentifierSyntax.self),
          .node(SuppressedTypeSyntax.self),
          .node(TupleTypeSyntax.self)
        ])
  }
}

extension Syntax {
  public static var structure: SyntaxNodeStructure {
    return .choices([
          .node(TokenSyntax.self),
          .node(AccessesEffectSyntax.self),
          .node(AccessorBlockSyntax.self),
          .node(AccessorDeclSyntax.self),
          .node(AccessorEffectSpecifiersSyntax.self),
          .node(AccessorInitEffectsSyntax.self),
          .node(AccessorListSyntax.self),
          .node(AccessorParameterSyntax.self),
          .node(ActorDeclSyntax.self),
          .node(ArrayElementListSyntax.self),
          .node(ArrayElementSyntax.self),
          .node(ArrayExprSyntax.self),
          .node(ArrayTypeSyntax.self),
          .node(ArrowExprSyntax.self),
          .node(AsExprSyntax.self),
          .node(AssignmentExprSyntax.self),
          .node(AssociatedtypeDeclSyntax.self),
          .node(AttributeListSyntax.self),
          .node(AttributeSyntax.self),
          .node(AttributedTypeSyntax.self),
          .node(AvailabilityArgumentSyntax.self),
          .node(AvailabilityConditionSyntax.self),
          .node(AvailabilityEntrySyntax.self),
          .node(AvailabilityLabeledArgumentSyntax.self),
          .node(AvailabilitySpecListSyntax.self),
          .node(AvailabilityVersionRestrictionListEntrySyntax.self),
          .node(AvailabilityVersionRestrictionListSyntax.self),
          .node(AvailabilityVersionRestrictionSyntax.self),
          .node(AwaitExprSyntax.self),
          .node(BackDeployedAttributeSpecListSyntax.self),
          .node(BinaryOperatorExprSyntax.self),
          .node(BooleanLiteralExprSyntax.self),
          .node(BorrowExprSyntax.self),
          .node(BreakStmtSyntax.self),
          .node(CanImportExprSyntax.self),
          .node(CanImportVersionInfoSyntax.self),
          .node(CaseItemListSyntax.self),
          .node(CaseItemSyntax.self),
          .node(CatchClauseListSyntax.self),
          .node(CatchClauseSyntax.self),
          .node(CatchItemListSyntax.self),
          .node(CatchItemSyntax.self),
          .node(ClassDeclSyntax.self),
          .node(ClassRestrictionTypeSyntax.self),
          .node(ClosureCaptureItemListSyntax.self),
          .node(ClosureCaptureItemSpecifierSyntax.self),
          .node(ClosureCaptureItemSyntax.self),
          .node(ClosureCaptureSignatureSyntax.self),
          .node(ClosureExprSyntax.self),
          .node(ClosureParamListSyntax.self),
          .node(ClosureParamSyntax.self),
          .node(ClosureParameterClauseSyntax.self),
          .node(ClosureParameterListSyntax.self),
          .node(ClosureParameterSyntax.self),
          .node(ClosureSignatureSyntax.self),
          .node(CodeBlockItemListSyntax.self),
          .node(CodeBlockItemSyntax.self),
          .node(CodeBlockSyntax.self),
          .node(CompositionTypeElementListSyntax.self),
          .node(CompositionTypeElementSyntax.self),
          .node(CompositionTypeSyntax.self),
          .node(ConditionElementListSyntax.self),
          .node(ConditionElementSyntax.self),
          .node(ConformanceRequirementSyntax.self),
          .node(ConstrainedSugarTypeSyntax.self),
          .node(ContinueStmtSyntax.self),
          .node(ConventionAttributeArgumentsSyntax.self),
          .node(ConventionWitnessMethodAttributeArgumentsSyntax.self),
          .node(CopyExprSyntax.self),
          .node(DeclModifierDetailSyntax.self),
          .node(DeclModifierSyntax.self),
          .node(DeclNameArgumentListSyntax.self),
          .node(DeclNameArgumentSyntax.self),
          .node(DeclNameArgumentsSyntax.self),
          .node(DeclNameSyntax.self),
          .node(DeferStmtSyntax.self),
          .node(DeinitEffectSpecifiersSyntax.self),
          .node(DeinitializerDeclSyntax.self),
          .node(DerivativeRegistrationAttributeArgumentsSyntax.self),
          .node(DesignatedTypeElementSyntax.self),
          .node(DesignatedTypeListSyntax.self),
          .node(DictionaryElementListSyntax.self),
          .node(DictionaryElementSyntax.self),
          .node(DictionaryExprSyntax.self),
          .node(DictionaryTypeSyntax.self),
          .node(DifferentiabilityParamListSyntax.self),
          .node(DifferentiabilityParamSyntax.self),
          .node(DifferentiabilityParamsClauseSyntax.self),
          .node(DifferentiabilityParamsSyntax.self),
          .node(DifferentiableAttributeArgumentsSyntax.self),
          .node(DiscardAssignmentExprSyntax.self),
          .node(DiscardStmtSyntax.self),
          .node(DoStmtSyntax.self),
          .node(DocumentationAttributeArgumentSyntax.self),
          .node(DocumentationAttributeArgumentsSyntax.self),
          .node(DynamicReplacementArgumentsSyntax.self),
          .node(EditorPlaceholderDeclSyntax.self),
          .node(EditorPlaceholderExprSyntax.self),
          .node(EffectsArgumentsSyntax.self),
          .node(EnumCaseDeclSyntax.self),
          .node(EnumCaseElementListSyntax.self),
          .node(EnumCaseElementSyntax.self),
          .node(EnumCaseParameterClauseSyntax.self),
          .node(EnumCaseParameterListSyntax.self),
          .node(EnumCaseParameterSyntax.self),
          .node(EnumDeclSyntax.self),
          .node(ExposeAttributeArgumentsSyntax.self),
          .node(ExprListSyntax.self),
          .node(ExpressionPatternSyntax.self),
          .node(ExpressionSegmentSyntax.self),
          .node(ExpressionStmtSyntax.self),
          .node(ExtensionDeclSyntax.self),
          .node(FallthroughStmtSyntax.self),
          .node(FloatLiteralExprSyntax.self),
          .node(ForInStmtSyntax.self),
          .node(ForcedValueExprSyntax.self),
          .node(FunctionCallExprSyntax.self),
          .node(FunctionDeclSyntax.self),
          .node(FunctionEffectSpecifiersSyntax.self),
          .node(FunctionParameterListSyntax.self),
          .node(FunctionParameterSyntax.self),
          .node(FunctionSignatureSyntax.self),
          .node(FunctionTypeSyntax.self),
          .node(GenericArgumentClauseSyntax.self),
          .node(GenericArgumentListSyntax.self),
          .node(GenericArgumentSyntax.self),
          .node(GenericParameterClauseSyntax.self),
          .node(GenericParameterListSyntax.self),
          .node(GenericParameterSyntax.self),
          .node(GenericRequirementListSyntax.self),
          .node(GenericRequirementSyntax.self),
          .node(GenericWhereClauseSyntax.self),
          .node(GuardStmtSyntax.self),
          .node(IdentifierExprSyntax.self),
          .node(IdentifierPatternSyntax.self),
          .node(IfConfigClauseListSyntax.self),
          .node(IfConfigClauseSyntax.self),
          .node(IfConfigDeclSyntax.self),
          .node(IfExprSyntax.self),
          .node(ImplementsAttributeArgumentsSyntax.self),
          .node(ImplicitlyUnwrappedOptionalTypeSyntax.self),
          .node(ImportDeclSyntax.self),
          .node(ImportPathComponentSyntax.self),
          .node(ImportPathSyntax.self),
          .node(InOutExprSyntax.self),
          .node(InfixOperatorExprSyntax.self),
          .node(InheritedTypeListSyntax.self),
          .node(InheritedTypeSyntax.self),
          .node(InitializerClauseSyntax.self),
          .node(InitializerDeclSyntax.self),
          .node(InitializesEffectSyntax.self),
          .node(IntegerLiteralExprSyntax.self),
          .node(IsExprSyntax.self),
          .node(IsTypePatternSyntax.self),
          .node(KeyPathComponentListSyntax.self),
          .node(KeyPathComponentSyntax.self),
          .node(KeyPathExprSyntax.self),
          .node(KeyPathOptionalComponentSyntax.self),
          .node(KeyPathPropertyComponentSyntax.self),
          .node(KeyPathSubscriptComponentSyntax.self),
          .node(LabeledSpecializeEntrySyntax.self),
          .node(LabeledStmtSyntax.self),
          .node(LayoutRequirementSyntax.self),
          .node(MacroDeclSyntax.self),
          .node(MacroExpansionDeclSyntax.self),
          .node(MacroExpansionExprSyntax.self),
          .node(MatchingPatternConditionSyntax.self),
          .node(MemberAccessExprSyntax.self),
          .node(MemberDeclBlockSyntax.self),
          .node(MemberDeclListItemSyntax.self),
          .node(MemberDeclListSyntax.self),
          .node(MemberTypeIdentifierSyntax.self),
          .node(MetatypeTypeSyntax.self),
          .node(MissingDeclSyntax.self),
          .node(MissingExprSyntax.self),
          .node(MissingPatternSyntax.self),
          .node(MissingStmtSyntax.self),
          .node(MissingSyntax.self),
          .node(MissingTypeSyntax.self),
          .node(ModifierListSyntax.self),
          .node(MoveExprSyntax.self),
          .node(MultipleTrailingClosureElementListSyntax.self),
          .node(MultipleTrailingClosureElementSyntax.self),
          .node(NamedOpaqueReturnTypeSyntax.self),
          .node(NilLiteralExprSyntax.self),
          .node(ObjCSelectorPieceSyntax.self),
          .node(ObjCSelectorSyntax.self),
          .node(OpaqueReturnTypeOfAttributeArgumentsSyntax.self),
          .node(OperatorDeclSyntax.self),
          .node(OperatorPrecedenceAndTypesSyntax.self),
          .node(OptionalBindingConditionSyntax.self),
          .node(OptionalChainingExprSyntax.self),
          .node(OptionalTypeSyntax.self),
          .node(OriginallyDefinedInArgumentsSyntax.self),
          .node(PackElementExprSyntax.self),
          .node(PackExpansionExprSyntax.self),
          .node(PackExpansionTypeSyntax.self),
          .node(PackReferenceTypeSyntax.self),
          .node(ParameterClauseSyntax.self),
          .node(PatternBindingListSyntax.self),
          .node(PatternBindingSyntax.self),
          .node(PostfixIfConfigExprSyntax.self),
          .node(PostfixUnaryExprSyntax.self),
          .node(PoundSourceLocationArgsSyntax.self),
          .node(PoundSourceLocationSyntax.self),
          .node(PrecedenceGroupAssignmentSyntax.self),
          .node(PrecedenceGroupAssociativitySyntax.self),
          .node(PrecedenceGroupAttributeListSyntax.self),
          .node(PrecedenceGroupDeclSyntax.self),
          .node(PrecedenceGroupNameElementSyntax.self),
          .node(PrecedenceGroupNameListSyntax.self),
          .node(PrecedenceGroupRelationSyntax.self),
          .node(PrefixOperatorExprSyntax.self),
          .node(PrimaryAssociatedTypeClauseSyntax.self),
          .node(PrimaryAssociatedTypeListSyntax.self),
          .node(PrimaryAssociatedTypeSyntax.self),
          .node(ProtocolDeclSyntax.self),
          .node(QualifiedDeclNameSyntax.self),
          .node(RegexLiteralExprSyntax.self),
          .node(RepeatWhileStmtSyntax.self),
          .node(ReturnClauseSyntax.self),
          .node(ReturnStmtSyntax.self),
          .node(SameTypeRequirementSyntax.self),
          .node(SequenceExprSyntax.self),
          .node(SimpleTypeIdentifierSyntax.self),
          .node(SourceFileSyntax.self),
          .node(SpecializeAttributeSpecListSyntax.self),
          .node(SpecializeExprSyntax.self),
          .node(StringLiteralExprSyntax.self),
          .node(StringLiteralSegmentsSyntax.self),
          .node(StringSegmentSyntax.self),
          .node(StructDeclSyntax.self),
          .node(SubscriptDeclSyntax.self),
          .node(SubscriptExprSyntax.self),
          .node(SuperRefExprSyntax.self),
          .node(SuppressedTypeSyntax.self),
          .node(SwitchCaseLabelSyntax.self),
          .node(SwitchCaseListSyntax.self),
          .node(SwitchCaseSyntax.self),
          .node(SwitchDefaultLabelSyntax.self),
          .node(SwitchExprSyntax.self),
          .node(TargetFunctionEntrySyntax.self),
          .node(TernaryExprSyntax.self),
          .node(ThrowStmtSyntax.self),
          .node(TryExprSyntax.self),
          .node(TupleExprElementListSyntax.self),
          .node(TupleExprElementSyntax.self),
          .node(TupleExprSyntax.self),
          .node(TuplePatternElementListSyntax.self),
          .node(TuplePatternElementSyntax.self),
          .node(TuplePatternSyntax.self),
          .node(TupleTypeElementListSyntax.self),
          .node(TupleTypeElementSyntax.self),
          .node(TupleTypeSyntax.self),
          .node(TypeAnnotationSyntax.self),
          .node(TypeEffectSpecifiersSyntax.self),
          .node(TypeExprSyntax.self),
          .node(TypeInheritanceClauseSyntax.self),
          .node(TypeInitializerClauseSyntax.self),
          .node(TypealiasDeclSyntax.self),
          .node(UnavailableFromAsyncArgumentsSyntax.self),
          .node(UnderscorePrivateAttributeArgumentsSyntax.self),
          .node(UnexpectedNodesSyntax.self),
          .node(UnresolvedAsExprSyntax.self),
          .node(UnresolvedIsExprSyntax.self),
          .node(UnresolvedPatternExprSyntax.self),
          .node(UnresolvedTernaryExprSyntax.self),
          .node(ValueBindingPatternSyntax.self),
          .node(VariableDeclSyntax.self),
          .node(VersionComponentListSyntax.self),
          .node(VersionComponentSyntax.self),
          .node(VersionTupleSyntax.self),
          .node(WhereClauseSyntax.self),
          .node(WhileStmtSyntax.self),
          .node(WildcardPatternSyntax.self),
          .node(YieldExprListElementSyntax.self),
          .node(YieldExprListSyntax.self),
          .node(YieldListSyntax.self),
          .node(YieldStmtSyntax.self)
        ])
  }
}
